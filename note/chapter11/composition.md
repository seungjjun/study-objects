# 합성과 유연한 설계

<br><br>

## 상속을 합성으로 변경하기
- 상속: 부모 클래스와 자식 클래스를 연결해서 부모 클래스의 코드를 재사용
  - 부모 클래스와 자식 클래스 사이의 의존성은 컴파일 타임 시점에 해결
  - 상속 관계는 **is-a 관계**라고 부른다.
- 합성: 전체를 표현하는 객체가 부분을 표현하는 객체를 포함해서 부분 객체의 코드를 재사용
  - 두 객체 사이의 의존성은 런타임 시점에 해결
  - 합성 관계는 **has-a 관계**라고 부른다.

상속을 제대로 활용하기 위해서는 부모 클래스의 내부 구현에 대해 상세하게 알아야 하기 때문에 자식 클래스와 부모 클래스 사이의 결합도가 높아진다.  

합성은 구현에 의존하지 않는다는 점에서 상속과 다르다.  
합성은 내부에 포함되는 객체의 구현이 아닌 퍼블릭 인터페이스에 의존한다. 따라서 합성을 이용하면 포함된 객체의 내부 구현이 변경되더라도 영향을 최소화할 수 있기 때문에 변경에 더 안정적인 코드를 얻을 수 있게 된다.

<br>

상속 관계는 클래스 사이의 **정적**인 관계인 데 비해 합성 관계는 객체 사이의 **동적**인 관계다.  
이 말은 코드 작성 시점에 결정한 상속 관계는 변경이 불가능하지만 합성 관계는 실행 시점에 동적으로 변경할 수 있다.  
즉, 상속 대신 합성을 사용하면 변경하기 쉽고 유연한 설계를 얻을 수 있다.

#### 상속을 남용했을 때 직면할 수 있는 문제
- 불필요한 인터페이스 상속 문제
- 메서드 오버라이딩의 오작용 문제
- 부모 클래스와 자식 클래스의 동시 수정 문제

합성을 사용하면 상속이 초래하는 세 가지 문제점을 해결할 수 있다.  
상속을 합성으로 바꾸는 방법은 자식 클래스에 선언된 상속 관계를 제거하고 부모 클래스의 인스턴스를 자식 클래스의 인스턴스 변수로 선언하면 된다.


## 객체 합성이 클래스 상속보다 더 좋은 방법이다.
다양한 종류의 객체와 협력하기 위해 합성 관계를 사용하는 경우에는 합성하는 객체의 타입을 인터페이스나 추상 클래스로 선언하고 의존성 주입을 사용해 런타임에 필요한 객체를 설정할 수 있도록 구현하는 것이 일반적이다.

상속은 부모 클래스의 세부적인 구현에 자식 클래스를 강하게 결합시키기 때문에 코드의 진화를 방해한다.  
코드를 재사용하면서도 건전한 결합도를 유지할 수 있는 더 좋은 방법은 합성을 이용하는 것이다.  
상속이 구현을 재사용하는 데 비해 합성은 객체의 인터페이스를 재사용한다.

## 믹스인
합성이 상속과 같은 문제점을 초래하지 않는 이유는 클래스의 구체적인 구현이 아니라 객체의 추상적인 인터페이스에 의존하기 때문이다.  

- 믹스인: 객체를 생성할 때 코드 일부를 클래스 안에 섞어 넣어 재사용하는 기법

합성이 런타임 시점에 객체를 조합하는 재사용 방법이라면 믹스인은 컴파일 시점에 필요한 코드 조각을 조합하는 재사용 방법

믹스인은 합성처럼 유연하면서도 상속처럼 쉽게 코드를 재사용할 수 있는 방법이다.
