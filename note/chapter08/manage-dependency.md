# 의존성 관리하기

<br><br>

## 의존성 이해하기
의존성이란 의존하고 있는 대상의 변경에 영향을 받을 수 있는 가능성이다.

### 변경과 의존성
의존성은 어떤 객체가 협력하기 위해 다른 객체를 필요로 할 때 두 객체 사이에 의존성이 생기게 된다.  

- 실행 시점: 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
- 구현 시점: 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.

두 요소 사이의 의존성은 의존되는 요소가 변경될 때 의존하는 요소도 함께 **변경**될 수 있다는 것을 의미한다.  
즉, 의존성은 자신이 의존하는 대상이 변경될 때 함께 변경될 수 있다는 특성이 있다.

### 의존성 전이
의존성은 전이될 수 있다.  
예를 들어 A객체가 B객체에 의존하고 있을 때, A객체는 B객체가 의존하는 대상에 대해서도 자동으로 의존하게 된다.  
즉, B객체가 갖고 있는 의존성이 B객체를 의존하고 있는 A객체에게도 전이된다는 것이다.

#### 의존성의 종류
- 직접 의존성: 한 요소가 다른 요소에 직접 의존하는 경우
- 간접 의존성: 직접적인 관계는 존재하지 않지만, 의존성 전이에 의해 영향이 전파되는 경우

### 런타임 의존성과 컴파일타임 의존성
- 런타임: 애플리케이션이 실행되는 시점
- 컴파일타임: 일반적으로 컴파일타임은 코드를 컴파일 하는 시점을 가리키지만 문맥에 따라 코드 그 자체를 가리키기도 한다.

어떤 클래스의 인스턴스가 다양한 클래스의 인스턴스와 협력하기 위해서는 협력할 인스턴스의 구체적인 클래스를 알아서는 안 된다.  
실제로 협력할 객체가 어떤 것인지는 **런타임**에 해결해야 한다.  

클래스가 협력할 객체의 클래스를 명시적으로 드러내고 있다면 다른 클래스의 인스턴스와 협력할 가능성 자체가 없어진다.  

### `유연하고 확장 가능한 설계를 만들기 위해서는 컴파일타임 의존성과 런타임 의존성이 달라야 한다.`

### 의존성 해결하기
컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 **의존성 해결**이라고 부른다.  
의존성 해결의 세가지 방법
- 객체를 생성하는 시점에 생성자를 통해 의존성 해결
- 객체 생성 후 setter 메서드를 통해 의존성 해결
- 메서드 실행 시 인자를 이용해 의존성 해결

## 유연한 설계
### 의존성과 결합도
의존성은 객체들의 협력을 가능하게 만드는 매개체이지만 의존성이 과하면 문제가될 수 있다.

예를 들어, Movie라는 클래스가 PercentDiscountPolicy에 직접 의존하고 있다면 Movie는 할인 정책을 PercentDiscountPolicy만 사용한다고 명시를 한것이 된다.  
다시 말해 다른 종류의 할인 정책이 추가되어도 Movie를 재사용할 수 있는 가능성을 없애 버린 것이다.

의존성이 다양한 환경에서 **재사용**할 수 있다면 그 의존성은 바람직한 의존성이다.  
즉, 바람직한 의존성은 **재사용성**과 관련이 있다.

두 요소 사이에 존재하는 의존성이 바람직할 때 두 요소가 **느슨한 결합도** 또는 **약한 결합도**를 갖는다고 말한다.  
두 요소 사이의 의존성이 바람직하지 못할 떄 **단단한 결합도** 또는 **강한 결합도**를 가진다고 말한다.
